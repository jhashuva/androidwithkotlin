{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Android with Kotlin This site take you from basic data types to most advanced concepts","title":"Home"},{"location":"#welcome-to-android-with-kotlin","text":"This site take you from basic data types to most advanced concepts","title":"Welcome to Android with Kotlin"},{"location":"collections/","text":"Lists Lists are ordered collections of elements. List elements can be acessed programitically through their indices Elements can occur more than once in a list. An example of a list is a sentence: it's a group of words, their order is important, and they can repeat. Immutable list Declare a list using immutable list using listOf() val countries = listOf(\"India\",\"Us\",\"South Africa\",\"UK\") println(countries) Output: [India,Us,South Africa,UK] Mutable list Lists can be changed using mutableListOf() val myList = mutableListOf(\"stand\",\"hardrive\",\"camera\") myList.remove(\"stand\") Output: kotlin.Boolean = true With a list defined with val , you can't change which list the variable refers to, but you can still change the contents of the list. Arrays Arrays store multiple items. Array elements can be accessed programmatically through their indices. Array elements are mutable. Array size is fixed. Array using arrayOf() An array of strings can be created using arrayOf() val colors = arrayOf(\"red\",\"green\",\"yellow\") println(java.util.Arrays.toString(colors)) Output: [red,green,yellow] With an array defined with val , you can't change which array the variable refers to, but you can still change the contents of the array. Arrays with mixed or single types An array can contain different types val mix = arrayOf(\"hats\",2) An array also contain just one type(integers in this case) val numbers = intArrayOf(1,2,3) Combining arrays Use the + operator val number1 = intArrayOf(1,2,3) val number2 = intArrayOf(4,5,6) val combined = numbers2+numbers println(Arrays.toString(combined)) Output: [4, 5, 6, 1, 2, 3]","title":"Collections"},{"location":"collections/#lists","text":"Lists are ordered collections of elements. List elements can be acessed programitically through their indices Elements can occur more than once in a list. An example of a list is a sentence: it's a group of words, their order is important, and they can repeat.","title":"Lists"},{"location":"collections/#immutable-list","text":"Declare a list using immutable list using listOf() val countries = listOf(\"India\",\"Us\",\"South Africa\",\"UK\") println(countries) Output: [India,Us,South Africa,UK]","title":"Immutable list"},{"location":"collections/#mutable-list","text":"Lists can be changed using mutableListOf() val myList = mutableListOf(\"stand\",\"hardrive\",\"camera\") myList.remove(\"stand\") Output: kotlin.Boolean = true With a list defined with val , you can't change which list the variable refers to, but you can still change the contents of the list.","title":"Mutable list"},{"location":"collections/#arrays","text":"Arrays store multiple items. Array elements can be accessed programmatically through their indices. Array elements are mutable. Array size is fixed.","title":"Arrays"},{"location":"collections/#array-using-arrayof","text":"An array of strings can be created using arrayOf() val colors = arrayOf(\"red\",\"green\",\"yellow\") println(java.util.Arrays.toString(colors)) Output: [red,green,yellow] With an array defined with val , you can't change which array the variable refers to, but you can still change the contents of the array.","title":"Array using arrayOf()"},{"location":"collections/#arrays-with-mixed-or-single-types","text":"An array can contain different types val mix = arrayOf(\"hats\",2) An array also contain just one type(integers in this case) val numbers = intArrayOf(1,2,3)","title":"Arrays with mixed or single types"},{"location":"collections/#combining-arrays","text":"Use the + operator val number1 = intArrayOf(1,2,3) val number2 = intArrayOf(4,5,6) val combined = numbers2+numbers println(Arrays.toString(combined)) Output: [4, 5, 6, 1, 2, 3]","title":"Combining arrays"},{"location":"conditions/","text":"Kotiln features several ways to implement conditional logic: - if/Else statements - When statements - For Loops - While loops if/Else statements val a = 10 val b = 20 if(a>b){ println(\"a is great\") } else { println(\"b is great\") } Output: b is great If statement with multiple cases val books = 10 if (books == 0){ println('No books') } else if (books < 20){ println('few books') } else { println(\"More books\") } Output: few books Ranges in if/else statments Data types containing a span of comparable values (e.g. integers from 1 to 100 inclusive) Ranges are bounded Objects within a range can be mutable or immutable. val numberOfEmployees = 50 if (numberOfEmployees in 1..100) { println(\"numberOfEmployees\") } Output: 50 when statement when(results) 0 -> println(\"No Results\") in 1..39 -> println(\"Got Results\") else -> println(\"That's a lot of results\") Output: That's a lot of results Note: As well as a when statement, you can also define a when expression that provides a return value. for Loops val pets = arrayOf(\"dog\",\"cat\",\"rabbit\") for (element in pets){ print(element + \" \") } Output: dog cat rabbit You don't need to define an iterator variable and increment it for each pass. for loops: elements and indexes for((index, element) in pets.withIndex()){ println(\"Item at $index is $element\\n\") } Output: Item at 0 is dog Item at 1 is cat Item at 2 is robbit for loops: step sizes and ranges for(i in 1..5) print(i) Output: 12345 for(i in 5 downTo 1) print(i) Output: 54321 for(i in 3..6 step 2) print(i) Output: 35 for(i in 'd'..'g') print(i) Output: defg while loops var chairs = 0 while(chairs<50){ chairs++ } println(\"There are $chairs chairs available\\n\") Output: There are 50 chairs available do { chairs-- } while(chairs>50) println(\"$chairs chairs available\") Output: 49 chairs available repeat loops repeat(3){ print(\"Hey\") } Output: HeyHeyHey","title":"Conditional Statements"},{"location":"conditions/#ifelse-statements","text":"val a = 10 val b = 20 if(a>b){ println(\"a is great\") } else { println(\"b is great\") } Output: b is great","title":"if/Else statements"},{"location":"conditions/#if-statement-with-multiple-cases","text":"val books = 10 if (books == 0){ println('No books') } else if (books < 20){ println('few books') } else { println(\"More books\") } Output: few books","title":"If statement with multiple cases"},{"location":"conditions/#ranges-in-ifelse-statments","text":"Data types containing a span of comparable values (e.g. integers from 1 to 100 inclusive) Ranges are bounded Objects within a range can be mutable or immutable. val numberOfEmployees = 50 if (numberOfEmployees in 1..100) { println(\"numberOfEmployees\") } Output: 50","title":"Ranges in if/else statments"},{"location":"conditions/#when-statement","text":"when(results) 0 -> println(\"No Results\") in 1..39 -> println(\"Got Results\") else -> println(\"That's a lot of results\") Output: That's a lot of results Note: As well as a when statement, you can also define a when expression that provides a return value.","title":"when statement"},{"location":"conditions/#for-loops","text":"val pets = arrayOf(\"dog\",\"cat\",\"rabbit\") for (element in pets){ print(element + \" \") } Output: dog cat rabbit You don't need to define an iterator variable and increment it for each pass.","title":"for Loops"},{"location":"conditions/#for-loops-elements-and-indexes","text":"for((index, element) in pets.withIndex()){ println(\"Item at $index is $element\\n\") } Output: Item at 0 is dog Item at 1 is cat Item at 2 is robbit","title":"for loops: elements and indexes"},{"location":"conditions/#for-loops-step-sizes-and-ranges","text":"for(i in 1..5) print(i) Output: 12345 for(i in 5 downTo 1) print(i) Output: 54321 for(i in 3..6 step 2) print(i) Output: 35 for(i in 'd'..'g') print(i) Output: defg","title":"for loops: step sizes and ranges"},{"location":"conditions/#while-loops","text":"var chairs = 0 while(chairs<50){ chairs++ } println(\"There are $chairs chairs available\\n\") Output: There are 50 chairs available do { chairs-- } while(chairs>50) println(\"$chairs chairs available\") Output: 49 chairs available","title":"while loops"},{"location":"conditions/#repeat-loops","text":"repeat(3){ print(\"Hey\") } Output: HeyHeyHey","title":"repeat loops"},{"location":"dtypes/","text":"Basic Data Types Integer types Type bits Notes Long 64 From -2 63 to 2 63 -1 Int 32 From -2 31 to 2 31 -1 Short 16 From -32768 to 32767 Byte 8 From -128 to 127 Now let us see how to declare int data types var a : Int = 12 println(a) Output: 12 val b : Long = 132432 println(b) Output: 132432 Var vs Val: var is like general variable and it's known as a mutable variable in kotlin and can be assigned multiple times. val is like Final variable and it's known as immutable in kotlin and can be initialized only single time. var c: Byte = 123 println(c) c = 113 println(c) Expected Output: 123 113 Same way: val d: Long = 1234567 println(d) d = 765467 println(d) Expected Output: Val cannot be reassigned Unsigned Integers Kotlin provieds following types of unsigned integers UByte : an unsigned 8-bit integer ranges from 0 to 255. UShort : an unsigned 16-bit integer ranges from o to 65535. UInt : an unsigned 32-bit integer, ranges from 0 to 2 32 -1 ULong : an unsigned 64-bit integer, ranges from 0 to 2 64 -1 Unsigned types support most of the operations of their signed counterparts. fun main(){ val a:UByte =12u val b:UShort = 234u val c:UInt = 2554u val d:ULong = 12345657545u println(a) println(b) println(c) println(d) } Output: 12 234 2554 12345657545 If you try to pass the signed number to unsigned variable it throws an exception: fun main(){ val c:UInt = -2554u println(c) } The output would looks like this: Unresolved reference. None of the following candidates is applicable because of receiver type mismatch: public inline operator fun BigDecimal.unaryMinus(): BigDecimal defined in kotlin public inline operator fun BigInteger.unaryMinus(): BigInteger defined in kotlin Type cast from unsigned to signed and back to unsigned: fun main(){ val c:UInt = 2554u val d:Int = c.toInt() val e:UInt = c.toUInt() println(d) println(e) } Output: 2554 2554 Type cast from signed to unsigned to signed: fun main(){ val c:Int = -2554 val d:UInt = c.toUInt() val e:Int = c.toInt() println(d) println(e) } Output: 4294964742 -2554 Floating point data types Type bits Notes Double 64 16 - 17 significant digits Float 32 6 - 7 significant digits val d: Double = 123.45678 println(d) output: 123.45678 val f: Float = 123.45 println(f) output: 123.45 Literal Constants There are the following kinds of literal constants for integral values: Decimals: 123 Longs are tagged by a capital L: 123L Hexadecimals: 0x0F Binaries: 0b00001011 Kotlin also supports a conventional notation for floating-point numbers: Doubles by default: 123.5 , 123.5e10 Floats are tagged by f or F: 123.5f You can use underscores to make number constants more readable: val oneMillion = 1_000_000 val creditCardNumber = 1234_5678_9012_3456L val socialSecurityNumber = 999_99_9999L val hexBytes = 0xFF_EC_DE_5E val bytes = 0b11010010_01101001_10010100_10010010 Boolean Type bits Notes Boolean 8 True or false. Operations include: || - lazy disjunction, && - lazy conjunction, ! - negation val myTrue: Boolean = true val myFalse: Boolean = false println(myTrue || myFalse) println(myTrue && myFalse) println(!myTrue) output: true false false Characters Characters are represented by the type Char . Character literals go in single quotes: '1' . Special characters start from an escaping backslash \\ . The following escape sequences are supported: \\t , \\b , \\n , \\r , \\ , \\\" , \\\\ and \\$ . To encode any other character, use the Unicode escape sequence syntax: \\uFF00 . val aChar: Char = 'a' println(aChar) println('\\n') //prints an extra newline character println('\\uFF00') output: a \uff00 Strings Strings are any sequence of characters enclosed by double quotes. val s1: String = \"Hello World\" println(s1) Output: Hello World String literals can contain escape characters. val s2: String = \"Hello World\\n\" println(s1) Output: Hello World Or any arbitrary text delimited by a triple quote (\"\"\") val s3: String = \"\"\" Arbitary text \"\"\" println(s3) Output: Arbitary text String concatenation val cats = 3 val dogs = 5 \"I have $cats cats\"+\" and $dogs dogs\" Output: I have 3 cats and 5 dogs String templates A template expression starts with a dollar sign ($) and can be a simple value: val f = 12 println(\"f = $f\") Output: f = 12 val s = \"androidwithkotlin.xyz\" println(\"$s.length is ${s.length}\") Output: androidwithkotlin.xyz.length is 21 String template expressions val books = 12 val pens = 3 \"I have ${books + pens} items with me.\" Output: I have 15 items with me. Type checking and Type Casting val b: Byte = 1 val i: Int = b //Gives you error val i1: Int = b.toInt() Method to type toByte() Byte toInt() Int toShort() Short toLong() Long toFloat() Float toDouble() Double toChar() Char val l = 1L + 3 // Long + Int => Long # Null Safety In kotlin, variables cannot be null by default. You can explicitly assiagn a variable to null using the safe call operator. Allow null-pointer exceptions using the !! operator. You can test for null using the elvis (?:) operator. ### Variables cannot be null In kotlin, null variables are not allowed by default. ```kotlin var numberOfColors: Int = null Output: ```error: null can not be a value of a non-null value``` # Safe call operator The safe call operator (?), after the type indicates that a variable can be ```null```. Declare an ```Int?``` as nullable. ```kotlin var numberOfColors: Int?= null NOTE: In general, do not set a variable to null as it may have unwanted consequences. Testing for null Check whether the numberOfColors variable is not null . Then decrement that variable. var numberOfColors = 6 if (numberOfColors != null) { numberOfCOlors = numberOfColors.desc() } Now we can see the kotlin way of writing it, using the safe call operator. var numberOfColors = 6 numberOfColors = numberOfColors?.desc() The !! Operator We use the !! operator when we sure variable won't null. Use !! to force the variable into non-null type. Then we call methods/properties on it. val len = s!!.length The above mentioned statement will throw null point exception if s is null. Warning: Because !! will throws an exception, it should only be used when it would be exceptional to hold null value. Elvis operator Chain null tests with the ?: operator. numberOfBooks = numberOfBooks?.desc()?:0 The ?: operator is sometimes called the \"Elvis operator,\" because it's like a smiley on its side with a pompadour hairstyle, like Elvis Presley styled his hair. Medium article on kotlin basic data types: https://medium.com/@joshuaudayagiri/introduction-to-kotlin-data-types-6de7bc4f70d4","title":"Data types"},{"location":"dtypes/#basic-data-types","text":"","title":"Basic Data Types"},{"location":"dtypes/#integer-types","text":"Type bits Notes Long 64 From -2 63 to 2 63 -1 Int 32 From -2 31 to 2 31 -1 Short 16 From -32768 to 32767 Byte 8 From -128 to 127 Now let us see how to declare int data types var a : Int = 12 println(a) Output: 12 val b : Long = 132432 println(b) Output: 132432","title":"Integer types"},{"location":"dtypes/#var-vs-val","text":"var is like general variable and it's known as a mutable variable in kotlin and can be assigned multiple times. val is like Final variable and it's known as immutable in kotlin and can be initialized only single time. var c: Byte = 123 println(c) c = 113 println(c) Expected Output: 123 113 Same way: val d: Long = 1234567 println(d) d = 765467 println(d) Expected Output: Val cannot be reassigned","title":"Var vs Val:"},{"location":"dtypes/#unsigned-integers","text":"Kotlin provieds following types of unsigned integers UByte : an unsigned 8-bit integer ranges from 0 to 255. UShort : an unsigned 16-bit integer ranges from o to 65535. UInt : an unsigned 32-bit integer, ranges from 0 to 2 32 -1 ULong : an unsigned 64-bit integer, ranges from 0 to 2 64 -1 Unsigned types support most of the operations of their signed counterparts. fun main(){ val a:UByte =12u val b:UShort = 234u val c:UInt = 2554u val d:ULong = 12345657545u println(a) println(b) println(c) println(d) } Output: 12 234 2554 12345657545 If you try to pass the signed number to unsigned variable it throws an exception: fun main(){ val c:UInt = -2554u println(c) } The output would looks like this: Unresolved reference. None of the following candidates is applicable because of receiver type mismatch: public inline operator fun BigDecimal.unaryMinus(): BigDecimal defined in kotlin public inline operator fun BigInteger.unaryMinus(): BigInteger defined in kotlin Type cast from unsigned to signed and back to unsigned: fun main(){ val c:UInt = 2554u val d:Int = c.toInt() val e:UInt = c.toUInt() println(d) println(e) } Output: 2554 2554 Type cast from signed to unsigned to signed: fun main(){ val c:Int = -2554 val d:UInt = c.toUInt() val e:Int = c.toInt() println(d) println(e) } Output: 4294964742 -2554","title":"Unsigned Integers"},{"location":"dtypes/#floating-point-data-types","text":"Type bits Notes Double 64 16 - 17 significant digits Float 32 6 - 7 significant digits val d: Double = 123.45678 println(d) output: 123.45678 val f: Float = 123.45 println(f) output: 123.45","title":"Floating point data types"},{"location":"dtypes/#literal-constants","text":"There are the following kinds of literal constants for integral values: Decimals: 123 Longs are tagged by a capital L: 123L Hexadecimals: 0x0F Binaries: 0b00001011 Kotlin also supports a conventional notation for floating-point numbers: Doubles by default: 123.5 , 123.5e10 Floats are tagged by f or F: 123.5f You can use underscores to make number constants more readable: val oneMillion = 1_000_000 val creditCardNumber = 1234_5678_9012_3456L val socialSecurityNumber = 999_99_9999L val hexBytes = 0xFF_EC_DE_5E val bytes = 0b11010010_01101001_10010100_10010010","title":"Literal Constants"},{"location":"dtypes/#boolean","text":"Type bits Notes Boolean 8 True or false. Operations include: || - lazy disjunction, && - lazy conjunction, ! - negation val myTrue: Boolean = true val myFalse: Boolean = false println(myTrue || myFalse) println(myTrue && myFalse) println(!myTrue) output: true false false","title":"Boolean"},{"location":"dtypes/#characters","text":"Characters are represented by the type Char . Character literals go in single quotes: '1' . Special characters start from an escaping backslash \\ . The following escape sequences are supported: \\t , \\b , \\n , \\r , \\ , \\\" , \\\\ and \\$ . To encode any other character, use the Unicode escape sequence syntax: \\uFF00 . val aChar: Char = 'a' println(aChar) println('\\n') //prints an extra newline character println('\\uFF00') output: a \uff00","title":"Characters"},{"location":"dtypes/#strings","text":"Strings are any sequence of characters enclosed by double quotes. val s1: String = \"Hello World\" println(s1) Output: Hello World String literals can contain escape characters. val s2: String = \"Hello World\\n\" println(s1) Output: Hello World Or any arbitrary text delimited by a triple quote (\"\"\") val s3: String = \"\"\" Arbitary text \"\"\" println(s3) Output: Arbitary text","title":"Strings"},{"location":"dtypes/#string-concatenation","text":"val cats = 3 val dogs = 5 \"I have $cats cats\"+\" and $dogs dogs\" Output: I have 3 cats and 5 dogs","title":"String concatenation"},{"location":"dtypes/#string-templates","text":"A template expression starts with a dollar sign ($) and can be a simple value: val f = 12 println(\"f = $f\") Output: f = 12 val s = \"androidwithkotlin.xyz\" println(\"$s.length is ${s.length}\") Output: androidwithkotlin.xyz.length is 21","title":"String templates"},{"location":"dtypes/#string-template-expressions","text":"val books = 12 val pens = 3 \"I have ${books + pens} items with me.\" Output: I have 15 items with me.","title":"String template expressions"},{"location":"dtypes/#type-checking-and-type-casting","text":"val b: Byte = 1 val i: Int = b //Gives you error val i1: Int = b.toInt() Method to type toByte() Byte toInt() Int toShort() Short toLong() Long toFloat() Float toDouble() Double toChar() Char val l = 1L + 3 // Long + Int => Long # Null Safety In kotlin, variables cannot be null by default. You can explicitly assiagn a variable to null using the safe call operator. Allow null-pointer exceptions using the !! operator. You can test for null using the elvis (?:) operator. ### Variables cannot be null In kotlin, null variables are not allowed by default. ```kotlin var numberOfColors: Int = null Output: ```error: null can not be a value of a non-null value``` # Safe call operator The safe call operator (?), after the type indicates that a variable can be ```null```. Declare an ```Int?``` as nullable. ```kotlin var numberOfColors: Int?= null NOTE: In general, do not set a variable to null as it may have unwanted consequences.","title":"Type checking and Type Casting"},{"location":"dtypes/#testing-for-null","text":"Check whether the numberOfColors variable is not null . Then decrement that variable. var numberOfColors = 6 if (numberOfColors != null) { numberOfCOlors = numberOfColors.desc() } Now we can see the kotlin way of writing it, using the safe call operator. var numberOfColors = 6 numberOfColors = numberOfColors?.desc()","title":"Testing for null"},{"location":"dtypes/#the-operator","text":"We use the !! operator when we sure variable won't null. Use !! to force the variable into non-null type. Then we call methods/properties on it. val len = s!!.length The above mentioned statement will throw null point exception if s is null. Warning: Because !! will throws an exception, it should only be used when it would be exceptional to hold null value.","title":"The !! Operator"},{"location":"dtypes/#elvis-operator","text":"Chain null tests with the ?: operator. numberOfBooks = numberOfBooks?.desc()?:0 The ?: operator is sometimes called the \"Elvis operator,\" because it's like a smiley on its side with a pompadour hairstyle, like Elvis Presley styled his hair. Medium article on kotlin basic data types: https://medium.com/@joshuaudayagiri/introduction-to-kotlin-data-types-6de7bc4f70d4","title":"Elvis operator"},{"location":"functions/","text":"About Functions Generally a function is a block of code that can perform specific task. Function breaks large program into smaller modular chunks. Declare using the fun keyword. Can take arguments with either named or default arguments. fun printHello() { println(\"Hello World\") } You can call the above function by printHello() Unit returning functions A function that does not return any useful value, its return type is Unit. function printHello(name: String?): Unit { println(\"Hi There!\") } Unit is a type with only one value: Unit Unit returning functions The Unit return type decleration is optional. fun printHello(name: String?): Unit{ println('Hi there!') } Which is equivalent to: fun printHello(name: String?){ println(\"Hi there!\") } Function Arguments Functions may have different types of arguments. Default parameters Required parameters Named arguments Default paramenters Default values provides a fallback if no parameter value is passed. fun drive(speed: Strring = \"fast\") { println(\"driving $speed\") } drive() # driving fast drive(\"slow\") #driving slow drive(speed = \"turtle-like\") #driving turtle-like Required parameters If no default is specified for a parameter, the corresponding argument is required. fun tempToday(day: String, temp: Int) { println(\"Today is $day and it's $temp degrees\") } Default versus requred paramenters Functions can have a mix of default and required parameters. fun reformat(str: String, divideByCamelHumps: Boolean, wordSeprator: Char, normalizedCase: Boolean = true){ println('$str $divdeByCamelHUmps $wordSeprator $normalizedCase') Pass in required arguments reformat(\"Today is a day like no other day\", false,'-') Named arguments To improve readability, use named arguments for required arguments. reformat(str, divideByCamelHumps = false, wordSeparator = '_') It's considered good style to put default arguments after positional arguments, that way caller only have to specify the required arguments. Compact functions Single-expression functions Compact functions, or single-expression functions, make your code more concise and readable. fun double(x: Int): Int{ x * 2 } Short form of above function fun double(x: Int):Int = x*2 #compact version Lambdas and higher-order functions Kotlin functions can be stored in variables and data structures. They can be passed as arguments to, and returned from, other higher-order functions. You can use higher-order functions to create new \"built-in\" functions. Lambda functions A lambda is an expression that makes a function that has no name. var dirtyLevel = 20 val waterFilter = {level: Int -> level/2} println(waterFilter(dirtyLevel)) Output: 10 Syntax for function types Kotlin's syntax for function types is closely related to its syntax for lambdas. Declare a variable that holds a function. var waterFilter: (Int) -> Int = {level -> level/2} Here waterFilter is Variable name Higher-order functions Higher-order functions take functions as parameters, or return a function. fun encodeMsg(msg: String, encode: (String)->String): String{ return encode(msg) } The body of the code calls the function that was passed as the second argument, and passes the first argument along to it. To call this function, pass it a string and function. val enc1: (String) -> String = { input -> input.toUpperCase()} println(encodeMsg(\"abc\", enc1)) Using a function type seperates its implementation from its usage. Passing a function reference Use the :: operator to pass a named function as an argument to another function. fun enc2(input:String): String = input.reversed() encodeMesage(\"abc\",::enc2) The :: operator lets kotlin know that you are passing the function reference as an argument, and not trying to call the function. Last parameter call syntax Kotlin prefers that any parameter that takes a function is the last parameter. encodeMessage(\"acronym\", {input -> input.toUpperCase() }) You can pass a lambda as a function parameter without putting it inside the parentheses. encodeMsg(\"acronym\") { input-> input.toUpperCase() } Using higher-order functions Many kotlin built-in functions are defined using last parameter call syntax. inline fun repeat(times: Int, action: (Int)->Unit) repeat(3){ print(\"Hello\") } List filters List filters Get part of a list based on some condition. red red-orange dark red orange bright orange saffron Apply filter() on list Condition: element contains \"red\" red red-orange dark red Iterating through lists If a function literal has only one parameter, you can omit its decleration and the \"->\". The parameter is implicitly declared under the name it . val ints = listOf(1,2,3) ints.filter{ it>0} Filter iterates through a collection, where it is the value of the element during the iteration. This is equivalent to: ints.filter{ n: Int -> n > 0} // OR ints.filter{ n-> n>0} List filters The filter condition in culry braces {} tests each item as the filter loops through. If the expression returns true , the item is included. val books = listOf(\"nature\",\"biology\",\"birds\") println(books.filter{ it[0]=='b'}) Output: [biology, birds] Eager and lazy filters Evaluation of expressions in lists. Eager: Occurs regardless of whether the result is ever used. Lazy: Occurs only if necessary at runtime. Lazy evaluation of lists is useful if you don't need the entire result, or if the list is exceptionally large and multiple copies wouldn't fit into RAM. Eager filters Filters are eager by default. A new list is created each time you use a filter. val instruments = listOf(\"viola\",\"cello\",\"violin\") val eager = instruments.filter{ it[0]=='v' } println() Output: eager:[viola, violin] Lazy filters Sequences are data strucutres that use lazy evalution, and can be used with filters to make them lazy. val instruments = listOf(\"viola\",\"cello\",\"violin\") val filtered = instruments.asSequence().filter{ it[0]=='v' } println(\"filtered: \"+ filtered) Sequences -> lists Sequences can be turned back into lists using toList(). val filtered = instruments.asSequence().filter{ it[0]=='v'} val newList = filtered.toList() println(\"new list:\"+ newList) Output: new list: [viola, violin] Other list transformations map() performs the same transform on every item and returns the list. val numbers= setOf(1, 2, 3) println(numbers.map { it * 3}) Output: [3, 6, 9] flatten() returns a single list of all the elements of nested collections. val numberSets = listOf(setOf(1,2,3), setOf(4,5), setOf(1,2)) println(numberSets.flatten()) Output: [1, 2, 3, 4, 5, 1, 2]","title":"Functions"},{"location":"functions/#about-functions","text":"Generally a function is a block of code that can perform specific task. Function breaks large program into smaller modular chunks. Declare using the fun keyword. Can take arguments with either named or default arguments. fun printHello() { println(\"Hello World\") } You can call the above function by printHello()","title":"About Functions"},{"location":"functions/#unit-returning-functions","text":"A function that does not return any useful value, its return type is Unit. function printHello(name: String?): Unit { println(\"Hi There!\") } Unit is a type with only one value: Unit","title":"Unit returning functions"},{"location":"functions/#unit-returning-functions_1","text":"The Unit return type decleration is optional. fun printHello(name: String?): Unit{ println('Hi there!') } Which is equivalent to: fun printHello(name: String?){ println(\"Hi there!\") }","title":"Unit returning functions"},{"location":"functions/#function-arguments","text":"Functions may have different types of arguments. Default parameters Required parameters Named arguments","title":"Function Arguments"},{"location":"functions/#default-paramenters","text":"Default values provides a fallback if no parameter value is passed. fun drive(speed: Strring = \"fast\") { println(\"driving $speed\") } drive() # driving fast drive(\"slow\") #driving slow drive(speed = \"turtle-like\") #driving turtle-like","title":"Default paramenters"},{"location":"functions/#required-parameters","text":"If no default is specified for a parameter, the corresponding argument is required. fun tempToday(day: String, temp: Int) { println(\"Today is $day and it's $temp degrees\") }","title":"Required parameters"},{"location":"functions/#default-versus-requred-paramenters","text":"Functions can have a mix of default and required parameters. fun reformat(str: String, divideByCamelHumps: Boolean, wordSeprator: Char, normalizedCase: Boolean = true){ println('$str $divdeByCamelHUmps $wordSeprator $normalizedCase') Pass in required arguments reformat(\"Today is a day like no other day\", false,'-')","title":"Default versus requred paramenters"},{"location":"functions/#named-arguments","text":"To improve readability, use named arguments for required arguments. reformat(str, divideByCamelHumps = false, wordSeparator = '_') It's considered good style to put default arguments after positional arguments, that way caller only have to specify the required arguments.","title":"Named arguments"},{"location":"functions/#compact-functions","text":"","title":"Compact functions"},{"location":"functions/#single-expression-functions","text":"Compact functions, or single-expression functions, make your code more concise and readable. fun double(x: Int): Int{ x * 2 } Short form of above function fun double(x: Int):Int = x*2 #compact version","title":"Single-expression functions"},{"location":"functions/#lambdas-and-higher-order-functions","text":"Kotlin functions can be stored in variables and data structures. They can be passed as arguments to, and returned from, other higher-order functions. You can use higher-order functions to create new \"built-in\" functions.","title":"Lambdas and higher-order functions"},{"location":"functions/#lambda-functions","text":"A lambda is an expression that makes a function that has no name. var dirtyLevel = 20 val waterFilter = {level: Int -> level/2} println(waterFilter(dirtyLevel)) Output: 10","title":"Lambda functions"},{"location":"functions/#syntax-for-function-types","text":"Kotlin's syntax for function types is closely related to its syntax for lambdas. Declare a variable that holds a function. var waterFilter: (Int) -> Int = {level -> level/2} Here waterFilter is Variable name","title":"Syntax for function types"},{"location":"functions/#higher-order-functions","text":"Higher-order functions take functions as parameters, or return a function. fun encodeMsg(msg: String, encode: (String)->String): String{ return encode(msg) } The body of the code calls the function that was passed as the second argument, and passes the first argument along to it. To call this function, pass it a string and function. val enc1: (String) -> String = { input -> input.toUpperCase()} println(encodeMsg(\"abc\", enc1)) Using a function type seperates its implementation from its usage.","title":"Higher-order functions"},{"location":"functions/#passing-a-function-reference","text":"Use the :: operator to pass a named function as an argument to another function. fun enc2(input:String): String = input.reversed() encodeMesage(\"abc\",::enc2) The :: operator lets kotlin know that you are passing the function reference as an argument, and not trying to call the function.","title":"Passing a function reference"},{"location":"functions/#last-parameter-call-syntax","text":"Kotlin prefers that any parameter that takes a function is the last parameter. encodeMessage(\"acronym\", {input -> input.toUpperCase() }) You can pass a lambda as a function parameter without putting it inside the parentheses. encodeMsg(\"acronym\") { input-> input.toUpperCase() }","title":"Last parameter call syntax"},{"location":"functions/#using-higher-order-functions","text":"Many kotlin built-in functions are defined using last parameter call syntax. inline fun repeat(times: Int, action: (Int)->Unit) repeat(3){ print(\"Hello\") }","title":"Using higher-order functions"},{"location":"functions/#list-filters","text":"","title":"List filters"},{"location":"functions/#list-filters_1","text":"Get part of a list based on some condition. red red-orange dark red orange bright orange saffron Apply filter() on list Condition: element contains \"red\" red red-orange dark red","title":"List filters"},{"location":"functions/#iterating-through-lists","text":"If a function literal has only one parameter, you can omit its decleration and the \"->\". The parameter is implicitly declared under the name it . val ints = listOf(1,2,3) ints.filter{ it>0} Filter iterates through a collection, where it is the value of the element during the iteration. This is equivalent to: ints.filter{ n: Int -> n > 0} // OR ints.filter{ n-> n>0}","title":"Iterating through lists"},{"location":"functions/#list-filters_2","text":"The filter condition in culry braces {} tests each item as the filter loops through. If the expression returns true , the item is included. val books = listOf(\"nature\",\"biology\",\"birds\") println(books.filter{ it[0]=='b'}) Output: [biology, birds]","title":"List filters"},{"location":"functions/#eager-and-lazy-filters","text":"Evaluation of expressions in lists. Eager: Occurs regardless of whether the result is ever used. Lazy: Occurs only if necessary at runtime. Lazy evaluation of lists is useful if you don't need the entire result, or if the list is exceptionally large and multiple copies wouldn't fit into RAM.","title":"Eager and lazy filters"},{"location":"functions/#eager-filters","text":"Filters are eager by default. A new list is created each time you use a filter. val instruments = listOf(\"viola\",\"cello\",\"violin\") val eager = instruments.filter{ it[0]=='v' } println() Output: eager:[viola, violin]","title":"Eager filters"},{"location":"functions/#lazy-filters","text":"Sequences are data strucutres that use lazy evalution, and can be used with filters to make them lazy. val instruments = listOf(\"viola\",\"cello\",\"violin\") val filtered = instruments.asSequence().filter{ it[0]=='v' } println(\"filtered: \"+ filtered)","title":"Lazy filters"},{"location":"functions/#sequences-lists","text":"Sequences can be turned back into lists using toList(). val filtered = instruments.asSequence().filter{ it[0]=='v'} val newList = filtered.toList() println(\"new list:\"+ newList) Output: new list: [viola, violin]","title":"Sequences -&gt; lists"},{"location":"functions/#other-list-transformations","text":"map() performs the same transform on every item and returns the list. val numbers= setOf(1, 2, 3) println(numbers.map { it * 3}) Output: [3, 6, 9] flatten() returns a single list of all the elements of nested collections. val numberSets = listOf(setOf(1,2,3), setOf(4,5), setOf(1,2)) println(numberSets.flatten()) Output: [1, 2, 3, 4, 5, 1, 2]","title":"Other list transformations"},{"location":"oops/","text":"Object Oriented Programming in Kotlin","title":"OOPS"},{"location":"oops/#object-oriented-programming-in-kotlin","text":"","title":"Object Oriented Programming in Kotlin"}]}